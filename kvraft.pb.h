// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvraft.proto

#ifndef PROTOBUF_kvraft_2eproto_INCLUDED
#define PROTOBUF_kvraft_2eproto_INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_kvraft_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsOperationImpl();
void InitDefaultsOperation();
void InitDefaultsKVArgsImpl();
void InitDefaultsKVArgs();
void InitDefaultsKVReplyImpl();
void InitDefaultsKVReply();
void InitDefaultsLogEntryImpl();
void InitDefaultsLogEntry();
void InitDefaultsRequestVoteArgsImpl();
void InitDefaultsRequestVoteArgs();
void InitDefaultsRequestVoteReplyImpl();
void InitDefaultsRequestVoteReply();
void InitDefaultsAppendEntriesArgsImpl();
void InitDefaultsAppendEntriesArgs();
void InitDefaultsAppendEntriesReplyImpl();
void InitDefaultsAppendEntriesReply();
inline void InitDefaults() {
  InitDefaultsOperation();
  InitDefaultsKVArgs();
  InitDefaultsKVReply();
  InitDefaultsLogEntry();
  InitDefaultsRequestVoteArgs();
  InitDefaultsRequestVoteReply();
  InitDefaultsAppendEntriesArgs();
  InitDefaultsAppendEntriesReply();
}
}  // namespace protobuf_kvraft_2eproto
namespace kvraft {
class AppendEntriesArgs;
class AppendEntriesArgsDefaultTypeInternal;
extern AppendEntriesArgsDefaultTypeInternal _AppendEntriesArgs_default_instance_;
class AppendEntriesReply;
class AppendEntriesReplyDefaultTypeInternal;
extern AppendEntriesReplyDefaultTypeInternal _AppendEntriesReply_default_instance_;
class KVArgs;
class KVArgsDefaultTypeInternal;
extern KVArgsDefaultTypeInternal _KVArgs_default_instance_;
class KVReply;
class KVReplyDefaultTypeInternal;
extern KVReplyDefaultTypeInternal _KVReply_default_instance_;
class LogEntry;
class LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class RequestVoteArgs;
class RequestVoteArgsDefaultTypeInternal;
extern RequestVoteArgsDefaultTypeInternal _RequestVoteArgs_default_instance_;
class RequestVoteReply;
class RequestVoteReplyDefaultTypeInternal;
extern RequestVoteReplyDefaultTypeInternal _RequestVoteReply_default_instance_;
}  // namespace kvraft
namespace google {
namespace protobuf {
template<> ::kvraft::AppendEntriesArgs* Arena::Create< ::kvraft::AppendEntriesArgs>(Arena*);
template<> ::kvraft::AppendEntriesReply* Arena::Create< ::kvraft::AppendEntriesReply>(Arena*);
template<> ::kvraft::KVArgs* Arena::Create< ::kvraft::KVArgs>(Arena*);
template<> ::kvraft::KVReply* Arena::Create< ::kvraft::KVReply>(Arena*);
template<> ::kvraft::LogEntry* Arena::Create< ::kvraft::LogEntry>(Arena*);
template<> ::kvraft::Operation* Arena::Create< ::kvraft::Operation>(Arena*);
template<> ::kvraft::RequestVoteArgs* Arena::Create< ::kvraft::RequestVoteArgs>(Arena*);
template<> ::kvraft::RequestVoteReply* Arena::Create< ::kvraft::RequestVoteReply>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace kvraft {

enum Operation_OpName {
  Operation_OpName_GET = 0,
  Operation_OpName_PUT = 1,
  Operation_OpName_DEL = 2,
  Operation_OpName_Operation_OpName_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Operation_OpName_Operation_OpName_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Operation_OpName_IsValid(int value);
const Operation_OpName Operation_OpName_OpName_MIN = Operation_OpName_GET;
const Operation_OpName Operation_OpName_OpName_MAX = Operation_OpName_DEL;
const int Operation_OpName_OpName_ARRAYSIZE = Operation_OpName_OpName_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operation_OpName_descriptor();
inline const ::std::string& Operation_OpName_Name(Operation_OpName value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operation_OpName_descriptor(), value);
}
inline bool Operation_OpName_Parse(
    const ::std::string& name, Operation_OpName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operation_OpName>(
    Operation_OpName_descriptor(), name, value);
}
enum KVResult {
  OK = 0,
  ErrNoKey = 1,
  ErrTimeout = 2,
  ErrWrongLeader = 3,
  KVResult_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KVResult_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KVResult_IsValid(int value);
const KVResult KVResult_MIN = OK;
const KVResult KVResult_MAX = ErrWrongLeader;
const int KVResult_ARRAYSIZE = KVResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* KVResult_descriptor();
inline const ::std::string& KVResult_Name(KVResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    KVResult_descriptor(), value);
}
inline bool KVResult_Parse(
    const ::std::string& name, KVResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KVResult>(
    KVResult_descriptor(), name, value);
}
// ===================================================================

class Operation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(Operation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Operation* other);
  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operation* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Operation>(NULL);
  }

  Operation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Operation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Operation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Operation_OpName OpName;
  static const OpName GET =
    Operation_OpName_GET;
  static const OpName PUT =
    Operation_OpName_PUT;
  static const OpName DEL =
    Operation_OpName_DEL;
  static inline bool OpName_IsValid(int value) {
    return Operation_OpName_IsValid(value);
  }
  static const OpName OpName_MIN =
    Operation_OpName_OpName_MIN;
  static const OpName OpName_MAX =
    Operation_OpName_OpName_MAX;
  static const int OpName_ARRAYSIZE =
    Operation_OpName_OpName_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpName_descriptor() {
    return Operation_OpName_descriptor();
  }
  static inline const ::std::string& OpName_Name(OpName value) {
    return Operation_OpName_Name(value);
  }
  static inline bool OpName_Parse(const ::std::string& name,
      OpName* value) {
    return Operation_OpName_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string key = 3;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 4;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // .kvraft.Operation.OpName op = 2;
  void clear_op();
  static const int kOpFieldNumber = 2;
  ::kvraft::Operation_OpName op() const;
  void set_op(::kvraft::Operation_OpName value);

  // @@protoc_insertion_point(class_scope:kvraft.Operation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int32 index_;
  int op_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsOperationImpl();
};
// -------------------------------------------------------------------

class KVArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.KVArgs) */ {
 public:
  KVArgs();
  virtual ~KVArgs();

  KVArgs(const KVArgs& from);

  inline KVArgs& operator=(const KVArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KVArgs(KVArgs&& from) noexcept
    : KVArgs() {
    *this = ::std::move(from);
  }

  inline KVArgs& operator=(KVArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KVArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KVArgs* internal_default_instance() {
    return reinterpret_cast<const KVArgs*>(
               &_KVArgs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(KVArgs* other);
  friend void swap(KVArgs& a, KVArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KVArgs* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<KVArgs>(NULL);
  }

  KVArgs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<KVArgs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KVArgs& from);
  void MergeFrom(const KVArgs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KVArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvraft.Operation command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  const ::kvraft::Operation& command() const;
  ::kvraft::Operation* release_command();
  ::kvraft::Operation* mutable_command();
  void set_allocated_command(::kvraft::Operation* command);

  // int32 clientid = 2;
  void clear_clientid();
  static const int kClientidFieldNumber = 2;
  ::google::protobuf::int32 clientid() const;
  void set_clientid(::google::protobuf::int32 value);

  // int32 seq = 3;
  void clear_seq();
  static const int kSeqFieldNumber = 3;
  ::google::protobuf::int32 seq() const;
  void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvraft.KVArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvraft::Operation* command_;
  ::google::protobuf::int32 clientid_;
  ::google::protobuf::int32 seq_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsKVArgsImpl();
};
// -------------------------------------------------------------------

class KVReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.KVReply) */ {
 public:
  KVReply();
  virtual ~KVReply();

  KVReply(const KVReply& from);

  inline KVReply& operator=(const KVReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KVReply(KVReply&& from) noexcept
    : KVReply() {
    *this = ::std::move(from);
  }

  inline KVReply& operator=(KVReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KVReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KVReply* internal_default_instance() {
    return reinterpret_cast<const KVReply*>(
               &_KVReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(KVReply* other);
  friend void swap(KVReply& a, KVReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KVReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<KVReply>(NULL);
  }

  KVReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<KVReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KVReply& from);
  void MergeFrom(const KVReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KVReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .kvraft.KVResult res = 1;
  void clear_res();
  static const int kResFieldNumber = 1;
  ::kvraft::KVResult res() const;
  void set_res(::kvraft::KVResult value);

  // @@protoc_insertion_point(class_scope:kvraft.KVReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int res_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsKVReplyImpl();
};
// -------------------------------------------------------------------

class LogEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.LogEntry) */ {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LogEntry* other);
  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogEntry* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LogEntry>(NULL);
  }

  LogEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LogEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvraft.Operation command = 1;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 1;
  const ::kvraft::Operation& command() const;
  ::kvraft::Operation* release_command();
  ::kvraft::Operation* mutable_command();
  void set_allocated_command(::kvraft::Operation* command);

  // int32 term = 2;
  void clear_term();
  static const int kTermFieldNumber = 2;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvraft.LogEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvraft::Operation* command_;
  ::google::protobuf::int32 term_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsLogEntryImpl();
};
// -------------------------------------------------------------------

class RequestVoteArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.RequestVoteArgs) */ {
 public:
  RequestVoteArgs();
  virtual ~RequestVoteArgs();

  RequestVoteArgs(const RequestVoteArgs& from);

  inline RequestVoteArgs& operator=(const RequestVoteArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteArgs(RequestVoteArgs&& from) noexcept
    : RequestVoteArgs() {
    *this = ::std::move(from);
  }

  inline RequestVoteArgs& operator=(RequestVoteArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteArgs* internal_default_instance() {
    return reinterpret_cast<const RequestVoteArgs*>(
               &_RequestVoteArgs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RequestVoteArgs* other);
  friend void swap(RequestVoteArgs& a, RequestVoteArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteArgs* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<RequestVoteArgs>(NULL);
  }

  RequestVoteArgs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<RequestVoteArgs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestVoteArgs& from);
  void MergeFrom(const RequestVoteArgs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestVoteArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // int32 candidateid = 2;
  void clear_candidateid();
  static const int kCandidateidFieldNumber = 2;
  ::google::protobuf::int32 candidateid() const;
  void set_candidateid(::google::protobuf::int32 value);

  // int32 lastlogindex = 3;
  void clear_lastlogindex();
  static const int kLastlogindexFieldNumber = 3;
  ::google::protobuf::int32 lastlogindex() const;
  void set_lastlogindex(::google::protobuf::int32 value);

  // int32 lastlogterm = 4;
  void clear_lastlogterm();
  static const int kLastlogtermFieldNumber = 4;
  ::google::protobuf::int32 lastlogterm() const;
  void set_lastlogterm(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvraft.RequestVoteArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 candidateid_;
  ::google::protobuf::int32 lastlogindex_;
  ::google::protobuf::int32 lastlogterm_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsRequestVoteArgsImpl();
};
// -------------------------------------------------------------------

class RequestVoteReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.RequestVoteReply) */ {
 public:
  RequestVoteReply();
  virtual ~RequestVoteReply();

  RequestVoteReply(const RequestVoteReply& from);

  inline RequestVoteReply& operator=(const RequestVoteReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteReply(RequestVoteReply&& from) noexcept
    : RequestVoteReply() {
    *this = ::std::move(from);
  }

  inline RequestVoteReply& operator=(RequestVoteReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteReply* internal_default_instance() {
    return reinterpret_cast<const RequestVoteReply*>(
               &_RequestVoteReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RequestVoteReply* other);
  friend void swap(RequestVoteReply& a, RequestVoteReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<RequestVoteReply>(NULL);
  }

  RequestVoteReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<RequestVoteReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestVoteReply& from);
  void MergeFrom(const RequestVoteReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestVoteReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // bool votegranted = 2;
  void clear_votegranted();
  static const int kVotegrantedFieldNumber = 2;
  bool votegranted() const;
  void set_votegranted(bool value);

  // @@protoc_insertion_point(class_scope:kvraft.RequestVoteReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 term_;
  bool votegranted_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsRequestVoteReplyImpl();
};
// -------------------------------------------------------------------

class AppendEntriesArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.AppendEntriesArgs) */ {
 public:
  AppendEntriesArgs();
  virtual ~AppendEntriesArgs();

  AppendEntriesArgs(const AppendEntriesArgs& from);

  inline AppendEntriesArgs& operator=(const AppendEntriesArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesArgs(AppendEntriesArgs&& from) noexcept
    : AppendEntriesArgs() {
    *this = ::std::move(from);
  }

  inline AppendEntriesArgs& operator=(AppendEntriesArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesArgs* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesArgs*>(
               &_AppendEntriesArgs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AppendEntriesArgs* other);
  friend void swap(AppendEntriesArgs& a, AppendEntriesArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesArgs* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AppendEntriesArgs>(NULL);
  }

  AppendEntriesArgs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AppendEntriesArgs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppendEntriesArgs& from);
  void MergeFrom(const AppendEntriesArgs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppendEntriesArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvraft.LogEntry entries = 6;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 6;
  ::kvraft::LogEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::kvraft::LogEntry >*
      mutable_entries();
  const ::kvraft::LogEntry& entries(int index) const;
  ::kvraft::LogEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::kvraft::LogEntry >&
      entries() const;

  // int32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // int32 leaderid = 2;
  void clear_leaderid();
  static const int kLeaderidFieldNumber = 2;
  ::google::protobuf::int32 leaderid() const;
  void set_leaderid(::google::protobuf::int32 value);

  // int32 prevlogindex = 3;
  void clear_prevlogindex();
  static const int kPrevlogindexFieldNumber = 3;
  ::google::protobuf::int32 prevlogindex() const;
  void set_prevlogindex(::google::protobuf::int32 value);

  // int32 prevlogterm = 4;
  void clear_prevlogterm();
  static const int kPrevlogtermFieldNumber = 4;
  ::google::protobuf::int32 prevlogterm() const;
  void set_prevlogterm(::google::protobuf::int32 value);

  // int32 leadercommit = 5;
  void clear_leadercommit();
  static const int kLeadercommitFieldNumber = 5;
  ::google::protobuf::int32 leadercommit() const;
  void set_leadercommit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvraft.AppendEntriesArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvraft::LogEntry > entries_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 leaderid_;
  ::google::protobuf::int32 prevlogindex_;
  ::google::protobuf::int32 prevlogterm_;
  ::google::protobuf::int32 leadercommit_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsAppendEntriesArgsImpl();
};
// -------------------------------------------------------------------

class AppendEntriesReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvraft.AppendEntriesReply) */ {
 public:
  AppendEntriesReply();
  virtual ~AppendEntriesReply();

  AppendEntriesReply(const AppendEntriesReply& from);

  inline AppendEntriesReply& operator=(const AppendEntriesReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesReply(AppendEntriesReply&& from) noexcept
    : AppendEntriesReply() {
    *this = ::std::move(from);
  }

  inline AppendEntriesReply& operator=(AppendEntriesReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesReply* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesReply*>(
               &_AppendEntriesReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(AppendEntriesReply* other);
  friend void swap(AppendEntriesReply& a, AppendEntriesReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesReply* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AppendEntriesReply>(NULL);
  }

  AppendEntriesReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AppendEntriesReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppendEntriesReply& from);
  void MergeFrom(const AppendEntriesReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppendEntriesReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // bool success = 2;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // int32 replicatedindex = 3;
  void clear_replicatedindex();
  static const int kReplicatedindexFieldNumber = 3;
  ::google::protobuf::int32 replicatedindex() const;
  void set_replicatedindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:kvraft.AppendEntriesReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 term_;
  bool success_;
  ::google::protobuf::int32 replicatedindex_;
  mutable int _cached_size_;
  friend struct ::protobuf_kvraft_2eproto::TableStruct;
  friend void ::protobuf_kvraft_2eproto::InitDefaultsAppendEntriesReplyImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Operation

// int32 index = 1;
inline void Operation::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 Operation::index() const {
  // @@protoc_insertion_point(field_get:kvraft.Operation.index)
  return index_;
}
inline void Operation::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:kvraft.Operation.index)
}

// .kvraft.Operation.OpName op = 2;
inline void Operation::clear_op() {
  op_ = 0;
}
inline ::kvraft::Operation_OpName Operation::op() const {
  // @@protoc_insertion_point(field_get:kvraft.Operation.op)
  return static_cast< ::kvraft::Operation_OpName >(op_);
}
inline void Operation::set_op(::kvraft::Operation_OpName value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:kvraft.Operation.op)
}

// string key = 3;
inline void Operation::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Operation::key() const {
  // @@protoc_insertion_point(field_get:kvraft.Operation.key)
  return key_.GetNoArena();
}
inline void Operation::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvraft.Operation.key)
}
#if LANG_CXX11
inline void Operation::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvraft.Operation.key)
}
#endif
inline void Operation::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvraft.Operation.key)
}
inline void Operation::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvraft.Operation.key)
}
inline ::std::string* Operation::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvraft.Operation.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_key() {
  // @@protoc_insertion_point(field_release:kvraft.Operation.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvraft.Operation.key)
}

// string value = 4;
inline void Operation::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Operation::value() const {
  // @@protoc_insertion_point(field_get:kvraft.Operation.value)
  return value_.GetNoArena();
}
inline void Operation::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvraft.Operation.value)
}
#if LANG_CXX11
inline void Operation::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvraft.Operation.value)
}
#endif
inline void Operation::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvraft.Operation.value)
}
inline void Operation::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvraft.Operation.value)
}
inline ::std::string* Operation::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvraft.Operation.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_value() {
  // @@protoc_insertion_point(field_release:kvraft.Operation.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvraft.Operation.value)
}

// -------------------------------------------------------------------

// KVArgs

// .kvraft.Operation command = 1;
inline bool KVArgs::has_command() const {
  return this != internal_default_instance() && command_ != NULL;
}
inline void KVArgs::clear_command() {
  if (GetArenaNoVirtual() == NULL && command_ != NULL) {
    delete command_;
  }
  command_ = NULL;
}
inline const ::kvraft::Operation& KVArgs::command() const {
  const ::kvraft::Operation* p = command_;
  // @@protoc_insertion_point(field_get:kvraft.KVArgs.command)
  return p != NULL ? *p : *reinterpret_cast<const ::kvraft::Operation*>(
      &::kvraft::_Operation_default_instance_);
}
inline ::kvraft::Operation* KVArgs::release_command() {
  // @@protoc_insertion_point(field_release:kvraft.KVArgs.command)
  
  ::kvraft::Operation* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::kvraft::Operation* KVArgs::mutable_command() {
  
  if (command_ == NULL) {
    command_ = ::google::protobuf::Arena::Create< ::kvraft::Operation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:kvraft.KVArgs.command)
  return command_;
}
inline void KVArgs::set_allocated_command(::kvraft::Operation* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:kvraft.KVArgs.command)
}

// int32 clientid = 2;
inline void KVArgs::clear_clientid() {
  clientid_ = 0;
}
inline ::google::protobuf::int32 KVArgs::clientid() const {
  // @@protoc_insertion_point(field_get:kvraft.KVArgs.clientid)
  return clientid_;
}
inline void KVArgs::set_clientid(::google::protobuf::int32 value) {
  
  clientid_ = value;
  // @@protoc_insertion_point(field_set:kvraft.KVArgs.clientid)
}

// int32 seq = 3;
inline void KVArgs::clear_seq() {
  seq_ = 0;
}
inline ::google::protobuf::int32 KVArgs::seq() const {
  // @@protoc_insertion_point(field_get:kvraft.KVArgs.seq)
  return seq_;
}
inline void KVArgs::set_seq(::google::protobuf::int32 value) {
  
  seq_ = value;
  // @@protoc_insertion_point(field_set:kvraft.KVArgs.seq)
}

// -------------------------------------------------------------------

// KVReply

// .kvraft.KVResult res = 1;
inline void KVReply::clear_res() {
  res_ = 0;
}
inline ::kvraft::KVResult KVReply::res() const {
  // @@protoc_insertion_point(field_get:kvraft.KVReply.res)
  return static_cast< ::kvraft::KVResult >(res_);
}
inline void KVReply::set_res(::kvraft::KVResult value) {
  
  res_ = value;
  // @@protoc_insertion_point(field_set:kvraft.KVReply.res)
}

// string value = 2;
inline void KVReply::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KVReply::value() const {
  // @@protoc_insertion_point(field_get:kvraft.KVReply.value)
  return value_.GetNoArena();
}
inline void KVReply::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvraft.KVReply.value)
}
#if LANG_CXX11
inline void KVReply::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvraft.KVReply.value)
}
#endif
inline void KVReply::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvraft.KVReply.value)
}
inline void KVReply::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvraft.KVReply.value)
}
inline ::std::string* KVReply::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvraft.KVReply.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KVReply::release_value() {
  // @@protoc_insertion_point(field_release:kvraft.KVReply.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KVReply::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvraft.KVReply.value)
}

// -------------------------------------------------------------------

// LogEntry

// .kvraft.Operation command = 1;
inline bool LogEntry::has_command() const {
  return this != internal_default_instance() && command_ != NULL;
}
inline void LogEntry::clear_command() {
  if (GetArenaNoVirtual() == NULL && command_ != NULL) {
    delete command_;
  }
  command_ = NULL;
}
inline const ::kvraft::Operation& LogEntry::command() const {
  const ::kvraft::Operation* p = command_;
  // @@protoc_insertion_point(field_get:kvraft.LogEntry.command)
  return p != NULL ? *p : *reinterpret_cast<const ::kvraft::Operation*>(
      &::kvraft::_Operation_default_instance_);
}
inline ::kvraft::Operation* LogEntry::release_command() {
  // @@protoc_insertion_point(field_release:kvraft.LogEntry.command)
  
  ::kvraft::Operation* temp = command_;
  command_ = NULL;
  return temp;
}
inline ::kvraft::Operation* LogEntry::mutable_command() {
  
  if (command_ == NULL) {
    command_ = ::google::protobuf::Arena::Create< ::kvraft::Operation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:kvraft.LogEntry.command)
  return command_;
}
inline void LogEntry::set_allocated_command(::kvraft::Operation* command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete command_;
  }
  if (command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:kvraft.LogEntry.command)
}

// int32 term = 2;
inline void LogEntry::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 LogEntry::term() const {
  // @@protoc_insertion_point(field_get:kvraft.LogEntry.term)
  return term_;
}
inline void LogEntry::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:kvraft.LogEntry.term)
}

// -------------------------------------------------------------------

// RequestVoteArgs

// int32 term = 1;
inline void RequestVoteArgs::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::term() const {
  // @@protoc_insertion_point(field_get:kvraft.RequestVoteArgs.term)
  return term_;
}
inline void RequestVoteArgs::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:kvraft.RequestVoteArgs.term)
}

// int32 candidateid = 2;
inline void RequestVoteArgs::clear_candidateid() {
  candidateid_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::candidateid() const {
  // @@protoc_insertion_point(field_get:kvraft.RequestVoteArgs.candidateid)
  return candidateid_;
}
inline void RequestVoteArgs::set_candidateid(::google::protobuf::int32 value) {
  
  candidateid_ = value;
  // @@protoc_insertion_point(field_set:kvraft.RequestVoteArgs.candidateid)
}

// int32 lastlogindex = 3;
inline void RequestVoteArgs::clear_lastlogindex() {
  lastlogindex_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::lastlogindex() const {
  // @@protoc_insertion_point(field_get:kvraft.RequestVoteArgs.lastlogindex)
  return lastlogindex_;
}
inline void RequestVoteArgs::set_lastlogindex(::google::protobuf::int32 value) {
  
  lastlogindex_ = value;
  // @@protoc_insertion_point(field_set:kvraft.RequestVoteArgs.lastlogindex)
}

// int32 lastlogterm = 4;
inline void RequestVoteArgs::clear_lastlogterm() {
  lastlogterm_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::lastlogterm() const {
  // @@protoc_insertion_point(field_get:kvraft.RequestVoteArgs.lastlogterm)
  return lastlogterm_;
}
inline void RequestVoteArgs::set_lastlogterm(::google::protobuf::int32 value) {
  
  lastlogterm_ = value;
  // @@protoc_insertion_point(field_set:kvraft.RequestVoteArgs.lastlogterm)
}

// -------------------------------------------------------------------

// RequestVoteReply

// int32 term = 1;
inline void RequestVoteReply::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 RequestVoteReply::term() const {
  // @@protoc_insertion_point(field_get:kvraft.RequestVoteReply.term)
  return term_;
}
inline void RequestVoteReply::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:kvraft.RequestVoteReply.term)
}

// bool votegranted = 2;
inline void RequestVoteReply::clear_votegranted() {
  votegranted_ = false;
}
inline bool RequestVoteReply::votegranted() const {
  // @@protoc_insertion_point(field_get:kvraft.RequestVoteReply.votegranted)
  return votegranted_;
}
inline void RequestVoteReply::set_votegranted(bool value) {
  
  votegranted_ = value;
  // @@protoc_insertion_point(field_set:kvraft.RequestVoteReply.votegranted)
}

// -------------------------------------------------------------------

// AppendEntriesArgs

// int32 term = 1;
inline void AppendEntriesArgs::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::term() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesArgs.term)
  return term_;
}
inline void AppendEntriesArgs::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesArgs.term)
}

// int32 leaderid = 2;
inline void AppendEntriesArgs::clear_leaderid() {
  leaderid_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::leaderid() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesArgs.leaderid)
  return leaderid_;
}
inline void AppendEntriesArgs::set_leaderid(::google::protobuf::int32 value) {
  
  leaderid_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesArgs.leaderid)
}

// int32 prevlogindex = 3;
inline void AppendEntriesArgs::clear_prevlogindex() {
  prevlogindex_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::prevlogindex() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesArgs.prevlogindex)
  return prevlogindex_;
}
inline void AppendEntriesArgs::set_prevlogindex(::google::protobuf::int32 value) {
  
  prevlogindex_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesArgs.prevlogindex)
}

// int32 prevlogterm = 4;
inline void AppendEntriesArgs::clear_prevlogterm() {
  prevlogterm_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::prevlogterm() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesArgs.prevlogterm)
  return prevlogterm_;
}
inline void AppendEntriesArgs::set_prevlogterm(::google::protobuf::int32 value) {
  
  prevlogterm_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesArgs.prevlogterm)
}

// int32 leadercommit = 5;
inline void AppendEntriesArgs::clear_leadercommit() {
  leadercommit_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::leadercommit() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesArgs.leadercommit)
  return leadercommit_;
}
inline void AppendEntriesArgs::set_leadercommit(::google::protobuf::int32 value) {
  
  leadercommit_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesArgs.leadercommit)
}

// repeated .kvraft.LogEntry entries = 6;
inline int AppendEntriesArgs::entries_size() const {
  return entries_.size();
}
inline void AppendEntriesArgs::clear_entries() {
  entries_.Clear();
}
inline ::kvraft::LogEntry* AppendEntriesArgs::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:kvraft.AppendEntriesArgs.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvraft::LogEntry >*
AppendEntriesArgs::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:kvraft.AppendEntriesArgs.entries)
  return &entries_;
}
inline const ::kvraft::LogEntry& AppendEntriesArgs::entries(int index) const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesArgs.entries)
  return entries_.Get(index);
}
inline ::kvraft::LogEntry* AppendEntriesArgs::add_entries() {
  // @@protoc_insertion_point(field_add:kvraft.AppendEntriesArgs.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvraft::LogEntry >&
AppendEntriesArgs::entries() const {
  // @@protoc_insertion_point(field_list:kvraft.AppendEntriesArgs.entries)
  return entries_;
}

// -------------------------------------------------------------------

// AppendEntriesReply

// int32 term = 1;
inline void AppendEntriesReply::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesReply::term() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesReply.term)
  return term_;
}
inline void AppendEntriesReply::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesReply.term)
}

// bool success = 2;
inline void AppendEntriesReply::clear_success() {
  success_ = false;
}
inline bool AppendEntriesReply::success() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesReply.success)
  return success_;
}
inline void AppendEntriesReply::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesReply.success)
}

// int32 replicatedindex = 3;
inline void AppendEntriesReply::clear_replicatedindex() {
  replicatedindex_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesReply::replicatedindex() const {
  // @@protoc_insertion_point(field_get:kvraft.AppendEntriesReply.replicatedindex)
  return replicatedindex_;
}
inline void AppendEntriesReply::set_replicatedindex(::google::protobuf::int32 value) {
  
  replicatedindex_ = value;
  // @@protoc_insertion_point(field_set:kvraft.AppendEntriesReply.replicatedindex)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kvraft

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kvraft::Operation_OpName> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvraft::Operation_OpName>() {
  return ::kvraft::Operation_OpName_descriptor();
}
template <> struct is_proto_enum< ::kvraft::KVResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvraft::KVResult>() {
  return ::kvraft::KVResult_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kvraft_2eproto_INCLUDED
